<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F%2Fblog%2F2017%2F03%2Fhello-world.html</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript跨域总结]]></title>
      <url>%2F%2Fblog%2F2016%2F07%2FJavaScript-Cross-Domain-Summary.html</url>
      <content type="text"><![CDATA[同源策略同源策略阻止从一个源加载的文档(document)或脚本获取或设置另一个源加载的文档(document)的属性。简单地说就是要求动态内容（例如，JavaScript或者VBScript）只能阅读与之同源的那些HTTP应答和cookies，而不能阅读来自不同源的内容。随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。 （1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 什么是跨域?两个页面只要协议(protocol)，端口(如果指定)，和主机三者中有任何一个不同，就被当作是跨域。下表给出了相对http://www.niices.com/demo/index.html同源检测的示例: URL 结果 原因 http://www.niices.com/dir/other.html 成功 http://www.niices.com/demo/inner/another.html 成功 https://www.niices.com/secure.html 失败 协议不同 http://www.niices.com:81/demo/etc.html 失败 端口不同 http://demo.niices.com/demo/other.html 失败 主机名不同 跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。注意：有些浏览器不允许从HTTPS的域跨域访问HTTP，比如Chrome和Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。 本文主要讨论如下五种跨域方法：1.通过JOSNP解决跨域问题2.CORS跨域资源共享3.document.domain+iframe跨域4.window.name+iframe实现的跨域数据传输5.使用HTML5的postMessage方法 通过JOSNP解决跨域问题通过日常的开发经验，我们可以得知。我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。而使用&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;等带有src标签都可以跨域加载资源,严格说这都是不符合同源要求的。 所以JSONP的原理就很简单了:本地创建一个函数,并将函数名用callback=functionName的形式传递给服务器端。服务器端动态创建本地函数的调用并把我们需要的JSON数据的形式以参数的形式返回。 123456&lt;script type="text/javascript"&gt; function functionName(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src="http://example.com/data.php?callback=functionName"&gt;&lt;/script&gt; JQuery封装的方法进行JSONP操作： 12345&lt;script type="text/javascript"&gt; $.getJSON('http://example.com/data.php?callback=?,function(jsondata)')&#123; //处理获得的json数据 &#125;);&lt;/script&gt; 这里的回调函数名可以用?代替，JQuery会自动帮你处理数据。 JSONP优缺点优点：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好 缺点：由于是使用的&lt;script&gt;标签，所以它只能支持GET请求而不支持POST等其它类型的HTTP请求； Tips： Ajax和JSONP这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此JQuery把JSONP作为Ajax的一种形式进行了封装； 但Ajax和JSONP其实本质上是不同的东西。Ajax的核心是通过XmlHttpRequest获取非本页内容，而JSONP的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 CORS跨域资源共享CORS(Cross-Origin Resource Sharing)定义一种跨域访问的机制，可以让AJAX实现跨域访问。 其基本原理就是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否。需要服务器端的支持，主要是通过设置Access-Control-Allow-Origin来进行。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 1Header set Access-Control-Allow-Origin \* 上面默认所有域都可以访问我们的服务器。 安全起见我们可以限制域访问： 1Access-Control-Allow-Origin: http://lover.niices.com 这样不是来自http:lover.niices.com域的请求就会报错。 客户端代码如下： 12345678var xhr = new XMLHttpRequest();xhr.open("GET", "http://demo.niices.com/xhr.php", true);xhr.send();xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText); &#125;&#125; 将Ajax请求的url由相对路径变成了我们需要跨域访问的绝对路径。 服务器端代码如下： 12345678910\&lt;?php$result = array ('a'=\&gt;1,'b'=\&gt;2,'c'=\&gt;3,'d'=\&gt;4,'e'=\&gt;5);header('content-type:application:json;charset=utf8');header('Access-Control-Allow-Origin:\*');header('Access-Control-Allow-Methods:POST');header('Access-Control-Allow-Headers:x-requested-with,content-type');echo json\_encode($result);?\&gt; CROS相比JSONP的优势1、JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。 2、使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。 3、JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS。 document.domain+iframe跨域对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。 不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是http://www.example.com/a.html，在这个页面里面有一个iframe，它的src是http://example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们无法通过页面a里的js代码来获取iframe中的东西。 a.html 123456789&lt;script type="text/javascript"&gt; function test()&#123; var iframe = document.getElementById('￼ifame'); var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的 var doc = win.document;//这里获取不到iframe里的document对象 var name = win.name;//这里同样获取不到window对象的name属性 &#125;&lt;/script&gt;&lt;iframe id = "iframe" src="http://example.com/b.html" onload = "test()"&gt;&lt;/iframe&gt; 这时候我们只要把http://www.example.com/a.html和http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。 a.html 1234567&lt;iframe id="iframe" src="http://demo.niices.com/b.html" onload = "test()"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt; document.domain = 'niices.com';//设置成主域 function test()&#123; alert(window.frames["iframeSon"].document;//contentWindow 可取得子窗口的 window 对象 &#125;&lt;/script&gt; b.html 123456&lt;script type="text/javascript"&gt; document.domain = 'niices.com';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同 function test()&#123; alert(parent.document.window);//contentWindow 可取得子窗口的 window 对象 &#125;&lt;/script&gt; window.name+iframe实现的跨域数据传输window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name持久存在一个窗口载入过的所有页面中有三个页面：a.com/app.html：应用页面。a.com/proxy.html：代理页面。一般是一个没有任何内容的html文件，需要和应用页面在同一域下。b.com/data.html：数据页面。应用页面需要获取数据的页面。基本原理：在应用页面动态创建iframe并将其src设置为数据页面，此时数据页面会将应用页面所需要的数据附加到iframe的window.name上，然后将iframe的src设置为代理页面，然后应用页面就可以拿到iframe中的数据（代理文件和应用页面在同一域下，所以可以相互通信）了。最后删除此iframe保证数据的安全。 基本步骤1.在应用页面中创建一个iframe，把其src指向数据页面。数据页面会把数据附加到这个iframe的window.name上，data.html代码如下： 1234&lt;script type="text/javascript"&gt; window.name = 'I was there!'; // 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右 // 数据格式可以自定义，如json、字符串&lt;/script&gt; 2.在应用页面中监听iframe的onload事件，当数据页面加载完毕后将iframe的src指向本地域的代理文件。此时应用页面就能获取所需的数据了。app.html部分代码如下： 1234567891011121314151617181920&lt;script type="text/javascript"&gt; var state = 0, iframe = document.createElement('iframe'), loadfn = function() &#123; if (state === 1) &#123; var data = iframe.contentWindow.name; // 读取数据 alert(data); //弹出'I was there!' &#125; else if (state === 0) &#123; state = 1; iframe.contentWindow.location = "http://a.com/proxy.html"; // 设置的代理文件 &#125; &#125;; iframe.src = 'http://b.com/data.html'; if (iframe.attachEvent) &#123; iframe.attachEvent('onload', loadfn); &#125; else &#123; iframe.onload = loadfn; &#125; document.body.appendChild(iframe);&lt;/script&gt; 3.获取数据以后销毁这个iframe，释放内存；这也保证数据安全。12345&lt;script type="text/javascript"&gt; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe);&lt;/script&gt; 使用HTML5的postMessage方法发送消息的postMessage方法：1otherWindow.postMessage(message, targetOrigin); otherWindow其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。message将要发送到其他window的数据，一般用JSON。targetOrigin是限定消息接收范围，不限制请使用 ‘*’ 接受数据的message事件123456789101112var onmessage = function (event) &#123; var data = event.data; var origin = event.origin; var source = event.source; // do something&#125;;if (typeof window.addEventListener != 'undefined') &#123; window.addEventListener('message', onmessage, false);&#125; else if (typeof window.attachEvent != 'undefined') &#123; //for ie window.attachEvent('onmessage', onmessage);&#125; 回调函数第一个参数接收一个event对象，有三个常用属性： data: 消息origin: 消息来源地址source: 源 DOMWindow 对象 举个栗子首先在a.html页面获取b.html页面的引用，并在b.html页面加载完成时向其发送数据，同时监听有没有从b.html页面返回的数据。http://blog.niices.com/a.html 123456789101112131415&lt;iframe id="iframe" src="http://demo.niices.com/b.html"&gt;&lt;/iframe&gt;&lt;script&gt;// 获取b.html页面的引用。var iframe=document.getElementById("iframe");// iframe加载完成后向其发送数据iframe.onload=function()&#123; iframe.contentWindow.postMessage(&#123;"age":21&#125;,"http://demo.niices.com");&#125;// 监听返回的数据function receiveMessage(event) &#123; if (event.origin !== "http://demo.niices.com") return; console.log(event.data)&#125;window.addEventListener('message', receiveMessage, false);&lt;/script&gt; 然后在b页面接受传递的消息，并在得到数据后返回一个确认的消息http://blog.niices.com/b.html 1234567891011&lt;script&gt;function receiveMessage(event)&#123; if (event.origin !== "http://blog.niices.com") return; console.log(data.age); // 接收到数据后返回一个确认消息 event.source.postMessage("I got the message!",event.origin);&#125;window.addEventListener("message", receiveMessage, false);&lt;/script&gt; 如果能看到下面的结果证明我们跨域成功了！ 参考来源HTTP访问控制(CORS)-MDNJavaScript跨域总结与解决办法详解js跨域问题window.postMessage-MDN使用window.postMessage实现跨域通信]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记一次修改Nginx服务器上Wordpress文件上传的大小限制]]></title>
      <url>%2F%2Fblog%2F2016%2F05%2FNginx-Wordpress-File-Upload-Size-Limit.html</url>
      <content type="text"><![CDATA[前言关于这个问题也碰到过几次了，大多数需求是需要在Wordpress后台通过HTTP协议上传大的视频文件，有时会遇到因为所在的服务器限制了上传文件大小而无法上传较大的附件，WordPress的媒体文件上传可以看到，大多数都是2MB或者8MB。如果是图片的话可能会还够用，但是如果是音频和视频文件就不一定够用了，所以在此做一个记录。服务器配置为：Nginx+PHP5+MySQL 查看PHP配置文件php.ini的路径首先在网站根目录下建一个info.php文件，文件内容如下： 123&lt;?phpecho phpinfo();?&gt; 然后在浏览器中访问这个文件，如：http://localhost/info.php 或者 http://www.niices.com/info.php我们可以看到php.ini的位置，如图：则该服务器上php.ini的位置是：/etc/php5/fpm/php.ini 修改php.ini文件编辑打开php.ini文件搜索如下字段：12345memory_limitpost_max_sizeupload_max_filesizemax_execution_timemax_input_time 一般默认的设置值为： 12345memory_limit=128M //单个线程可调用内存大小post_max_size=8M //设定 POST 数据所允许的最大大小。一般要设置的比upload_max_filesize大upload_max_filesize=2M //默认上传文件大小，这个就是2M的限制所在max_execution_time=30 //最大执行时间，页面等待时间，超过该时间脚本就会停止执行max_input_time=60 //限制通过POST、GET以及PUT方式接收数据的时间，一般设置为比max_execution_time大 然后将其改为自己需要的值，例如： 12345memory_limit=128Mpost_max_size=1200Mupload_max_filesize=1024M //这样就改为可以传1024M以下的文件了max_execution_time=300max_input_time=600 查看nginx配置文件nginx.conf的路径当我们执行nginx -t的时候，nginx会去测试我们的配置文件语法是否正确，同时也就告诉了我们配置文件的路径： 1$ nginx -t 结果如图：所以该服务器的nginx配置文件路径为/etc/nginx/nginx.conf 修改nginx.conf文件打开nginx.conf并在http{}(或者server{}或者location / {})字段里添加 1234567891011121314http &#123; ... client_max_body_size 1024M;&#125;//或者server &#123; ... client_max_body_size 1024M;&#125;//或者location / &#123; ... client_max_body_size 1024M;&#125; 重启服务使修改生效重新加载nginx服务 1$ /etc/init.d/nginx reload 重新加载之前可以先检查一下nginx配置文件是否正确 1$ nginx -t 重启php服务 1$ service php5-fpm restart 大功告成！]]></content>
    </entry>

    
  
  
</search>
