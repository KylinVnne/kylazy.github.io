<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>其逸居</title>
  <subtitle>我的运维之始</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kylinvnne.github.io/"/>
  <updated>2017-03-11T13:02:34.000Z</updated>
  <id>https://kylinvnne.github.io/</id>
  
  <author>
    <name>Kylin Vnne</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kylinvnne.github.io//blog/2017/03/hello-world.html"/>
    <id>https://kylinvnne.github.io//blog/2017/03/hello-world.html</id>
    <published>2017-03-13T02:50:03.938Z</published>
    <updated>2017-03-11T13:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript跨域总结</title>
    <link href="https://kylinvnne.github.io//blog/2016/07/JavaScript-Cross-Domain-Summary.html"/>
    <id>https://kylinvnne.github.io//blog/2016/07/JavaScript-Cross-Domain-Summary.html</id>
    <published>2016-07-20T12:22:33.000Z</published>
    <updated>2016-09-12T11:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略阻止从一个源加载的文档(document)或脚本获取或设置另一个源加载的文档(document)的属性。简单地说就是要求动态内容（例如，JavaScript或者VBScript）只能阅读与之同源的那些<code>HTTP</code>应答和<code>cookies</code>，而不能阅读来自不同源的内容。<br>随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<blockquote>
<p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。<br>（2） DOM 无法获得。<br>（3） AJAX 请求不能发送。</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域?"></a>什么是跨域?</h2><p>两个页面只要协议(protocol)，端口(如果指定)，和主机三者中有任何一个不同，就被当作是跨域。<br>下表给出了相对<code>http://www.niices.com/demo/index.html</code>同源检测的示例:</p>
<table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:center">结果</th>
<th style="text-align:center">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.niices.com/dir/other.html" target="_blank" rel="external">http://www.niices.com/dir/other.html</a></td>
<td style="text-align:center">成功</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.niices.com/demo/inner/another.html" target="_blank" rel="external">http://www.niices.com/demo/inner/another.html</a></td>
<td style="text-align:center">成功</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.niices.com/secure.html" target="_blank" rel="external">https://www.niices.com/secure.html</a></td>
<td style="text-align:center">失败</td>
<td style="text-align:center">协议不同</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.niices.com:81/demo/etc.html" target="_blank" rel="external">http://www.niices.com:81/demo/etc.html</a></td>
<td style="text-align:center">失败</td>
<td style="text-align:center">端口不同</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://demo.niices.com/demo/other.html" target="_blank" rel="external">http://demo.niices.com/demo/other.html</a></td>
<td style="text-align:center">失败</td>
<td style="text-align:center">主机名不同</td>
</tr>
</tbody>
</table>
<p>跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。注意：有些浏览器不允许从HTTPS的域跨域访问HTTP，比如Chrome和Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。</p>
<p>本文主要讨论如下五种跨域方法：<br>1.通过<code>JOSNP</code>解决跨域问题<br>2.<code>CORS</code>跨域资源共享<br>3.<code>document.domain</code>+<code>iframe</code>跨域<br>4.<code>window.name</code>+<code>iframe</code>实现的跨域数据传输<br>5.使用<code>HTML5</code>的<code>postMessage</code>方法</p>
<h2 id="通过JOSNP解决跨域问题"><a href="#通过JOSNP解决跨域问题" class="headerlink" title="通过JOSNP解决跨域问题"></a>通过<code>JOSNP</code>解决跨域问题</h2><p>通过日常的开发经验，我们可以得知。我们直接用<code>XMLHttpRequest</code>请求不同域上的数据时，是不可以的。而使用<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code>等带有<code>src</code>标签都可以跨域加载资源,严格说这都是不符合同源要求的。</p>
<p>所以JSONP的原理就很简单了:<br>本地创建一个函数,并将函数名用<code>callback=functionName</code>的形式传递给服务器端。服务器端动态创建本地函数的调用并把我们需要的<code>JSON</code>数据的形式以参数的形式返回。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function functionName(jsondata)&#123;</div><div class="line">        //处理获得的json数据</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src="http://example.com/data.php?callback=functionName"&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p><code>JQuery</code>封装的方法进行<code>JSONP</code>操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    $.getJSON(<span class="string">'http://example.com/data.php?callback=?,function(jsondata)'</span>)&#123;</div><div class="line">        <span class="comment">//处理获得的json数据</span></div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这里的回调函数名可以用?代替，<code>JQuery</code>会自动帮你处理数据。</p>
<h3 id="JSONP优缺点"><a href="#JSONP优缺点" class="headerlink" title="JSONP优缺点"></a><code>JSONP</code>优缺点</h3><p>优点：它不像<code>XMLHttpRequest</code>对象实现的<code>Ajax</code>请求那样受到同源策略的限制；它的兼容性更好</p>
<p>缺点：由于是使用的<code>&lt;script&gt;</code>标签，所以它只能支持<code>GET</code>请求而不支持<code>POST</code>等其它类型的<code>HTTP</code>请求；</p>
<p>Tips：</p>
<blockquote>
<p><code>Ajax</code>和<code>JSONP</code>这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个<code>url</code>，然后把服务器返回的数据进行处理，因此<code>JQuery</code>把<code>JSONP</code>作为<code>Ajax</code>的一种形式进行了封装；</p>
<p>但<code>Ajax</code>和<code>JSONP</code>其实本质上是不同的东西。<code>Ajax</code>的核心是通过<code>XmlHttpRequest</code>获取非本页内容，而<code>JSONP</code>的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的<code>js</code>脚本。</p>
</blockquote>
<h2 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a><code>CORS</code>跨域资源共享</h2><p><code>CORS(Cross-Origin Resource Sharing)</code>定义一种跨域访问的机制，可以让<code>AJAX</code>实现跨域访问。</p>
<p>其基本原理就是使用自定义的<code>HTTP</code>头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否。需要服务器端的支持，主要是通过设置<code>Access-Control-Allow-Origin</code>来进行。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Header set Access-Control-Allow-Origin \*</div></pre></td></tr></table></figure>
<p>上面默认所有域都可以访问我们的服务器。</p>
<p><img src="/images/2016/07/1.png" alt=""></p>
<p>安全起见我们可以限制域访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://lover.niices.com</div></pre></td></tr></table></figure>
<p>这样不是来自<code>http:lover.niices.com</code>域的请求就会报错。</p>
<p><img src="/images/2016/07/2.png" alt=""></p>
<p>客户端代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"http://demo.niices.com/xhr.php"</span>, <span class="literal">true</span>);</div><div class="line">xhr.send();</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</div><div class="line">	    <span class="built_in">console</span>.log(xhr.responseText);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将<code>Ajax</code>请求的<code>url</code>由相对路径变成了我们需要跨域访问的绝对路径。</p>
<p>服务器端代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">\<span class="meta">&lt;?php</span></div><div class="line">$result = <span class="keyword">array</span> (<span class="string">'a'</span>=\&gt;<span class="number">1</span>,<span class="string">'b'</span>=\&gt;<span class="number">2</span>,<span class="string">'c'</span>=\&gt;<span class="number">3</span>,<span class="string">'d'</span>=\&gt;<span class="number">4</span>,<span class="string">'e'</span>=\&gt;<span class="number">5</span>);</div><div class="line"></div><div class="line">header(<span class="string">'content-type:application:json;charset=utf8'</span>);</div><div class="line">header(<span class="string">'Access-Control-Allow-Origin:\*'</span>);</div><div class="line">header(<span class="string">'Access-Control-Allow-Methods:POST'</span>);</div><div class="line">header(<span class="string">'Access-Control-Allow-Headers:x-requested-with,content-type'</span>);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> json\_encode($result);</div><div class="line">?\&gt;</div></pre></td></tr></table></figure>
<h3 id="CROS相比JSONP的优势"><a href="#CROS相比JSONP的优势" class="headerlink" title="CROS相比JSONP的优势"></a><code>CROS</code>相比<code>JSONP</code>的优势</h3><p>1、<code>JSONP</code>只能实现<code>GET</code>请求，而<code>CORS</code>支持所有类型的<code>HTTP</code>请求。</p>
<p>2、使用<code>CORS</code>，开发者可以使用普通的<code>XMLHttpRequest</code>发起请求和获得数据，比起<code>JSONP</code>有更好的错误处理。</p>
<p>3、<code>JSONP</code>主要被老的浏览器支持，它们往往不支持<code>CORS</code>，而绝大多数现代浏览器都已经支持了<code>CORS</code>。</p>
<h2 id="document-domain-iframe跨域"><a href="#document-domain-iframe跨域" class="headerlink" title="document.domain+iframe跨域"></a><code>document.domain</code>+<code>iframe</code>跨域</h2><p>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。</p>
<p>不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<code>http://www.example.com/a.html</code>，在这个页面里面有一个<code>iframe</code>，它的src是<code>http://example.com/b.html</code>, 很显然，这个页面与它里面的<code>iframe</code>框架是不同域的，所以我们无法通过页面<code>a</code>里的<code>js</code>代码来获取<code>iframe</code>中的东西。</p>
<p>a.html</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function test()&#123;</div><div class="line">        var iframe = document.getElementById('￼ifame');</div><div class="line">        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</div><div class="line">        var doc = win.document;//这里获取不到iframe里的document对象</div><div class="line">        var name = win.name;//这里同样获取不到window对象的name属性</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe id = "iframe" src="http://example.com/b.html" onload = "test()"&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure>
<p>这时候我们只要把<code>http://www.example.com/a.html</code>和<code>http://example.com/b.html</code>这两个页面的<code>document.domain</code>都设成相同的域名就可以了。但要注意的是，<code>document.domain</code>的设置是有限制的，我们只能把<code>document.domain</code>设置成自身或更高一级的父域，且主域必须相同。</p>
<p>a.html</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://demo.niices.com/b.html"</span> onload = <span class="string">"test()"</span>&gt;&lt;/iframe&gt;</div><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'niices.com'</span>;<span class="comment">//设置成主域</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="built_in">window</span>.frames[<span class="string">"iframeSon"</span>].document;<span class="comment">//contentWindow 可取得子窗口的 window 对象</span></div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>b.html</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'niices.com'</span>;<span class="comment">//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(parent.document.window);<span class="comment">//contentWindow 可取得子窗口的 window 对象</span></div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<h2 id="window-name-iframe实现的跨域数据传输"><a href="#window-name-iframe实现的跨域数据传输" class="headerlink" title="window.name+iframe实现的跨域数据传输"></a><code>window.name</code>+<code>iframe</code>实现的跨域数据传输</h2><p><code>window</code>对象有个<code>name</code>属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对<code>window.name</code>都有读写的权限，<code>window.name</code>持久存在一个窗口载入过的所有页面中<br>有三个页面：<br>a.com/app.html：应用页面。<br>a.com/proxy.html：代理页面。一般是一个没有任何内容的html文件，需要和应用页面在同一域下。<br>b.com/data.html：数据页面。应用页面需要获取数据的页面。<br>基本原理：在应用页面动态创建<code>iframe</code>并将其<code>src</code>设置为数据页面，此时数据页面会将应用页面所需要的数据附加到<code>iframe</code>的<code>window.name</code>上，然后将<code>iframe</code>的<code>src</code>设置为代理页面，然后应用页面就可以拿到<code>iframe</code>中的数据（代理文件和应用页面在同一域下，所以可以相互通信）了。最后删除此<code>iframe</code>保证数据的安全。</p>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>1.在应用页面中创建一个iframe，把其src指向数据页面。<br>数据页面会把数据附加到这个iframe的window.name上，data.html代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">window</span>.name = <span class="string">'I was there!'</span>;    <span class="comment">// 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右</span></div><div class="line">                                     <span class="comment">// 数据格式可以自定义，如json、字符串</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>2.在应用页面中监听iframe的onload事件，当数据页面加载完毕后将iframe的src指向本地域的代理文件。此时应用页面就能获取所需的数据了。app.html部分代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> state = <span class="number">0</span>, </div><div class="line">    iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>),</div><div class="line">    loadfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">var</span> data = iframe.contentWindow.name;    <span class="comment">// 读取数据</span></div><div class="line">            alert(data);    <span class="comment">//弹出'I was there!'</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</div><div class="line">            state = <span class="number">1</span>;</div><div class="line">            iframe.contentWindow.location = <span class="string">"http://a.com/proxy.html"</span>;    <span class="comment">// 设置的代理文件</span></div><div class="line">        &#125;  </div><div class="line">    &#125;;</div><div class="line">    iframe.src = <span class="string">'http://b.com/data.html'</span>;</div><div class="line">    <span class="keyword">if</span> (iframe.attachEvent) &#123;</div><div class="line">        iframe.attachEvent(<span class="string">'onload'</span>, loadfn);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        iframe.onload  = loadfn;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>3.获取数据以后销毁这个iframe，释放内存；这也保证数据安全。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    iframe.contentWindow.document.write(<span class="string">''</span>);</div><div class="line">    iframe.contentWindow.close();</div><div class="line">    <span class="built_in">document</span>.body.removeChild(iframe);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h2 id="使用HTML5的postMessage方法"><a href="#使用HTML5的postMessage方法" class="headerlink" title="使用HTML5的postMessage方法"></a>使用<code>HTML5</code>的<code>postMessage</code>方法</h2><h3 id="发送消息的postMessage方法："><a href="#发送消息的postMessage方法：" class="headerlink" title="发送消息的postMessage方法："></a>发送消息的<code>postMessage</code>方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otherWindow.postMessage(message, targetOrigin);</div></pre></td></tr></table></figure>
<blockquote>
<p>otherWindow其他窗口的一个引用，比如<code>iframe</code>的<code>contentWindow</code>属性、执行<code>window.open</code>返回的窗口对象、或者是命名过或数值索引的<code>window.frames</code>。<br>message将要发送到其他<code>window</code>的数据，一般用<code>JSON</code>。<br>targetOrigin<br>是限定消息接收范围，不限制请使用 ‘*’</p>
</blockquote>
<h3 id="接受数据的message事件"><a href="#接受数据的message事件" class="headerlink" title="接受数据的message事件"></a>接受数据的<code>message</code>事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> data = event.data;</div><div class="line">	<span class="keyword">var</span> origin = event.origin;</div><div class="line">	<span class="keyword">var</span> source = event.source;</div><div class="line">	<span class="comment">// do something</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.addEventListener != <span class="string">'undefined'</span>) &#123;</div><div class="line">	<span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, onmessage, <span class="literal">false</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.attachEvent != <span class="string">'undefined'</span>) &#123;</div><div class="line">	<span class="comment">//for ie</span></div><div class="line">	<span class="built_in">window</span>.attachEvent(<span class="string">'onmessage'</span>, onmessage);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回调函数第一个参数接收一个<code>event</code>对象，有三个常用属性：</p>
<blockquote>
<p>data:  消息<br>origin:  消息来源地址<br>source:  源 DOMWindow 对象</p>
</blockquote>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>首先在<code>a.html</code>页面获取<code>b.html</code>页面的引用，并在<code>b.html</code>页面加载完成时向其发送数据，同时监听有没有从<code>b.html</code>页面返回的数据。<br><a href="http://blog.niices.com/a.html" target="_blank" rel="external">http://blog.niices.com/a.html</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://demo.niices.com/b.html"</span>&gt;&lt;/iframe&gt;</div><div class="line">&lt;script&gt;</div><div class="line"><span class="comment">// 获取b.html页面的引用。</span></div><div class="line"><span class="keyword">var</span> iframe=<span class="built_in">document</span>.getElementById(<span class="string">"iframe"</span>);</div><div class="line"><span class="comment">// iframe加载完成后向其发送数据</span></div><div class="line">iframe.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  iframe.contentWindow.postMessage(&#123;<span class="string">"age"</span>:<span class="number">21</span>&#125;,<span class="string">"http://demo.niices.com"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 监听返回的数据</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (event.origin !== <span class="string">"http://demo.niices.com"</span>)          <span class="keyword">return</span>;</div><div class="line">    <span class="built_in">console</span>.log(event.data)</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage, <span class="literal">false</span>);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>然后在b页面接受传递的消息，并在得到数据后返回一个确认的消息<br><a href="http://blog.niices.com/b.html" target="_blank" rel="external">http://blog.niices.com/b.html</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (event.origin !== <span class="string">"http://blog.niices.com"</span>)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  <span class="built_in">console</span>.log(data.age);</div><div class="line">  <span class="comment">// 接收到数据后返回一个确认消息</span></div><div class="line">  event.source.postMessage(<span class="string">"I got the message!"</span>,event.origin);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>如果能看到下面的结果证明我们跨域成功了！<br><img src="/images/2016/08/1.png" alt=""></p>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP访问控制(CORS)-MDN</a><br><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="external">JavaScript跨域总结与解决办法</a><br><a href="https://segmentfault.com/a/1190000000718840#articleHeader6" target="_blank" rel="external">详解js跨域问题</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">window.postMessage-MDN</a><br><a href="http://www.css88.com/archives/4720" target="_blank" rel="external">使用window.postMessage实现跨域通信</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;p&gt;同源策略阻止从一个源加载的文档(document)或脚本获取或设置另一个源加载的文档(document)的属性。简单地说就是要求动态内容（例如，JavaScript或者VBScript）只能阅读与之同源的那些&lt;code&gt;HTTP&lt;/code&gt;应答和&lt;code&gt;cookies&lt;/code&gt;，而不能阅读来自不同源的内容。&lt;br&gt;随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1） Cookie、LocalStorage 和 IndexDB 无法读取。&lt;br&gt;（2） DOM 无法获得。&lt;br&gt;（3） AJAX 请求不能发送。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://kylinvnne.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://kylinvnne.github.io/tags/JavaScript/"/>
    
      <category term="跨域" scheme="https://kylinvnne.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>记一次修改Nginx服务器上Wordpress文件上传的大小限制</title>
    <link href="https://kylinvnne.github.io//blog/2016/05/Nginx-Wordpress-File-Upload-Size-Limit.html"/>
    <id>https://kylinvnne.github.io//blog/2016/05/Nginx-Wordpress-File-Upload-Size-Limit.html</id>
    <published>2016-05-04T12:22:33.000Z</published>
    <updated>2016-09-12T11:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于这个问题也碰到过几次了，大多数需求是需要在<code>Wordpress</code>后台通过<code>HTTP</code>协议上传大的视频文件，有时会遇到因为所在的服务器限制了上传文件大小而无法上传较大的附件，<code>WordPress</code>的媒体文件上传可以看到，大多数都是<code>2MB</code>或者<code>8MB</code>。如果是图片的话可能会还够用，但是如果是音频和视频文件就不一定够用了，所以在此做一个记录。<br>服务器配置为：<code>Nginx+PHP5+MySQL</code></p>
<a id="more"></a>
<h2 id="查看PHP配置文件php-ini的路径"><a href="#查看PHP配置文件php-ini的路径" class="headerlink" title="查看PHP配置文件php.ini的路径"></a>查看PHP配置文件<code>php.ini</code>的路径</h2><p>首先在网站根目录下建一个<code>info.php</code>文件，文件内容如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">echo</span> phpinfo();</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>然后在浏览器中访问这个文件，如：<code>http://localhost/info.php</code> 或者 <code>http://www.niices.com/info.php</code><br>我们可以看到<code>php.ini</code>的位置，如图：<br><img src="/images/2016/05/1.png" alt=""><br>则该服务器上<code>php.ini</code>的位置是：/etc/php5/fpm/php.ini</p>
<h2 id="修改php-ini文件"><a href="#修改php-ini文件" class="headerlink" title="修改php.ini文件"></a>修改<code>php.ini</code>文件</h2><p>编辑打开<code>php.ini</code>文件<br>搜索如下字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">memory_limit</div><div class="line">post_max_size</div><div class="line">upload_max_filesize</div><div class="line">max_execution_time</div><div class="line">max_input_time</div></pre></td></tr></table></figure></p>
<p>一般默认的设置值为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">memory_limit=128M　　　  //单个线程可调用内存大小</div><div class="line">post_max_size=8M　　　　 //设定 POST 数据所允许的最大大小。一般要设置的比upload_max_filesize大</div><div class="line">upload_max_filesize=2M　 //默认上传文件大小，这个就是2M的限制所在</div><div class="line">max_execution_time=30　　//最大执行时间，页面等待时间，超过该时间脚本就会停止执行</div><div class="line">max_input_time=60　　　　//限制通过POST、GET以及PUT方式接收数据的时间，一般设置为比max_execution_time大</div></pre></td></tr></table></figure>
<p>然后将其改为自己需要的值，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">memory_limit=128M</div><div class="line">post_max_size=1200M</div><div class="line">upload_max_filesize=1024M　//这样就改为可以传1024M以下的文件了</div><div class="line">max_execution_time=300</div><div class="line">max_input_time=600</div></pre></td></tr></table></figure>
<h2 id="查看nginx配置文件nginx-conf的路径"><a href="#查看nginx配置文件nginx-conf的路径" class="headerlink" title="查看nginx配置文件nginx.conf的路径"></a>查看<code>nginx</code>配置文件<code>nginx.conf</code>的路径</h2><p>当我们执行<code>nginx -t</code>的时候，<code>nginx</code>会去测试我们的配置文件语法是否正确，同时也就告诉了我们配置文件的路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nginx -t</div></pre></td></tr></table></figure>
<p>结果如图：<br><img src="/images/2016/05/2.png" alt=""><br>所以该服务器的<code>nginx</code>配置文件路径为<code>/etc/nginx/nginx.conf</code></p>
<h2 id="修改nginx-conf文件"><a href="#修改nginx-conf文件" class="headerlink" title="修改nginx.conf文件"></a>修改<code>nginx.conf</code>文件</h2><p>打开<code>nginx.conf</code>并在<code>http{}</code>(或者<code>server{}</code>或者<code>location / {}</code>)字段里添加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    ...</div><div class="line">    client_max_body_size 1024M;</div><div class="line">&#125;</div><div class="line">//或者</div><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    client_max_body_size 1024M;</div><div class="line">&#125;</div><div class="line">//或者</div><div class="line">location / &#123;</div><div class="line">    ...</div><div class="line">    client_max_body_size 1024M;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重启服务使修改生效"><a href="#重启服务使修改生效" class="headerlink" title="重启服务使修改生效"></a>重启服务使修改生效</h2><p>重新加载<code>nginx</code>服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ /etc/init.d/nginx reload</div></pre></td></tr></table></figure>
<p>重新加载之前可以先检查一下<code>nginx</code>配置文件是否正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nginx -t</div></pre></td></tr></table></figure>
<p>重启<code>php</code>服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service php5-fpm restart</div></pre></td></tr></table></figure>
<p>大功告成！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于这个问题也碰到过几次了，大多数需求是需要在&lt;code&gt;Wordpress&lt;/code&gt;后台通过&lt;code&gt;HTTP&lt;/code&gt;协议上传大的视频文件，有时会遇到因为所在的服务器限制了上传文件大小而无法上传较大的附件，&lt;code&gt;WordPress&lt;/code&gt;的媒体文件上传可以看到，大多数都是&lt;code&gt;2MB&lt;/code&gt;或者&lt;code&gt;8MB&lt;/code&gt;。如果是图片的话可能会还够用，但是如果是音频和视频文件就不一定够用了，所以在此做一个记录。&lt;br&gt;服务器配置为：&lt;code&gt;Nginx+PHP5+MySQL&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://kylinvnne.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="nginx" scheme="https://kylinvnne.github.io/tags/nginx/"/>
    
      <category term="Wordpress" scheme="https://kylinvnne.github.io/tags/Wordpress/"/>
    
      <category term="文件上传限制" scheme="https://kylinvnne.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%99%90%E5%88%B6/"/>
    
  </entry>
  
</feed>
